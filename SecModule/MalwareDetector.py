from typing import Dict, List


class MalwareDetector:
    def __init__(self):
        self.suspicious_patterns = {
            'crypto_mining': ['cryptonight', 'monero', 'bitcoin', 'mining', 'crypto'],
            'ransomware': ['encrypt', 'decrypt', 'ransom', 'bitcoin', 'aes', 'des'],
            'trojan': ['backdoor', 'keylogger', 'remote_access', 'shell', 'execute','execve'],
            'packer': ['upx', 'aspack', 'themida', 'vmprotect', 'pack', 'protect','compress'],
            'network_malicious': ['connect', 'socket', 'bind', 'listen', 'accept', 'send', 'recv'],
            'system_manipulation': ['createfile', 'writefile', 'regopen', 'regset', 'process'],
            'evasion': ['isdebuggerpresent', 'checkremote', 'antivirus', 'bypass','ptrace']
        }

        self.vulnerability_patterns = {
            'buffer_overflow': ['strcpy', 'gets', 'sprintf', 'strcat', 'scanf'],
            'format_string': ['printf', 'sprintf', 'fprintf', 'snprintf'],
            'injection': ['system', 'exec', 'execve', 'execute', 'popen', 'createprocess', 'shellexecute']
        }
        self.suspicious_keywords =  [
            'malware', 'virus', 'trojan', 'exploit', 'payload', 'inject',
            'backdoor', 'keylogger', 'rootkit', 'botnet', 'command', 'control',
            'crypt', 'encode', 'decode', 'obfuscate', 'bypass', 'disable',
            'elevate', 'privilege', 'admin', 'password', 'credential', 'steal'
        ]

    def parse_imports_table(self, imports_text: str) -> List[Dict]:
        """Parsa la tabella delle imports da radare2"""
        imports = []
        lines = imports_text.splitlines()

        # Salta le intestazioni
        start_processing = False
        for line in lines:
            line = line.strip()
            if not line:
                continue

            # Cerca l'inizio della tabella (dopo le intestazioni)
            if line.startswith('---'):
                start_processing = True
                continue

            if start_processing and line:
                # Parsa ogni riga della tabella
                parts = line.split()
                if len(parts) >= 5:
                    import_info = {
                        'ordinal': parts[0],
                        'address': parts[1],
                        'bind': parts[2],
                        'type': parts[3],
                        'library': parts[4],
                        'function': ' '.join(parts[5:])  # Per gestire nomi con spazi
                    }
                    imports.append(import_info)

        return imports

    def detect_suspicious_imports(self, imports_analysis: str) -> List[str]:
        """Rileva import sospetti dalla tabella radare2"""
        imports = self.parse_imports_table(imports_analysis)
        suspicious_found = []

        for import_item in imports:
            function_name = import_item['function'].lower()
            library_name = import_item['library'].lower()

            # Controlla ogni categoria di pattern sospetti
            for category, patterns in self.suspicious_patterns.items():
                for pattern in patterns:
                    if pattern in function_name or pattern in library_name :
                        suspicious_found.append(
                            f"{category}: {import_item['function']} (from {import_item['library']})")
                        break  # Evita duplicati per la stessa funzione

            # Controlla anche le librerie sospette
            suspicious_libraries = ['ws2_32', 'wininet', 'urlmon', 'advapi32']
            for lib in suspicious_libraries:
                if lib in library_name and import_item['function']:
                    suspicious_found.append(
                        f"network_activity: {import_item['function']} (from {import_item['library']})")

        return list(set(suspicious_found))  # Rimuove duplicati

    def analyze_imports_statistics(self, imports_analysis: str) -> Dict:
        """Fornisce statistiche sulle imports"""
        imports = self.parse_imports_table(imports_analysis)

        libraries = {}
        functions_by_lib = {}

        for import_item in imports:
            lib = import_item['library']
            func = import_item['function']

            # Conta per libreria
            libraries[lib] = libraries.get(lib, 0) + 1

            # Raggruppa funzioni per libreria
            if lib not in functions_by_lib:
                functions_by_lib[lib] = []
            functions_by_lib[lib].append(func)

        return {
            'total_imports': len(imports),
            'libraries_count': len(libraries),
            'libraries_breakdown': libraries,
            'top_libraries': sorted(libraries.items(), key=lambda x: x[1], reverse=True)[:5],
            'functions_by_library': functions_by_lib
        }

    def analyze_strings(self, strings_output: str) -> Dict:
        """Analizza le stringhe per indicatori di compromesso"""
        analysis = {
            'suspicious_urls': self._extract_urls(strings_output),
            'ip_addresses': self._extract_ips(strings_output),
            'suspicious_keywords': self._find_suspicious_keywords(strings_output),
            'potential_domains': self._extract_domains(strings_output),
            'file_paths': self._extract_file_paths(strings_output)
        }
        return analysis

    def _extract_urls(self, text: str):
        import re

        # Pattern per URL completi
        full_url_patterns = [
            r'https?://[^\s"\'<>]+',
            r'ftp://[^\s"\'<>]+',
            r'tcp://[^\s"\'<>]+'
        ]

        # Pattern per domini nudi
        bare_domain_pattern = r'\b(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}\b'

        urls = []

        #  estrai URL completi
        for pattern in full_url_patterns:
            urls.extend(re.findall(pattern, text))

        #  rimuovi contenuti già coperti dagli URL completi
        text_without_full_urls = text
        for url in urls:
            text_without_full_urls = text_without_full_urls.replace(url, " ")

        #  ora estrai solo domini che NON compaiono già negli URL completi
        bare_domains = re.findall(bare_domain_pattern, text_without_full_urls)
        # Filtra falsi positivi
        blacklist_ext = {"dll", "exe", "sys", "bat", "cmd","startup","text","GNU","property","version","hash","plt","sec","build","so","got","dyn"}
        bare_domains = [
            d for d in bare_domains
            if d.split(".")[-1].lower() not in blacklist_ext
        ]

        # Aggiungi schema ai domini
        bare_domains = [f"http://{d}" for d in bare_domains]

        # Unisci tutto senza duplicati
        cleaned_urls = set(urls + bare_domains)

        # Rimuovi punteggiatura finale
        final_urls = []
        for u in cleaned_urls:
            u = re.sub(r'[.,;!?\)\]}>]+$', '', u)
            final_urls.append(u)

        return final_urls

    def _extract_ips(self, text: str) -> List[str]:
        import re
        ip_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
        return re.findall(ip_pattern, text)

    def _extract_domains(self, text: str) -> List[str]:
        import re
        domain_pattern = r'\b[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.([a-zA-Z]{2,})\b'
        return re.findall(domain_pattern, text)

    def _extract_file_paths(self, text: str) -> List[str]:
        import re
        path_pattern = r'[c-zC-Z]:\\[^\s]+|\/[^\s]+'
        return re.findall(path_pattern, text)

    def _find_suspicious_keywords(self, text: str) -> List[str]:

        found = []
        text_lower = text.lower()
        for keyword in self.suspicious_keywords:
            if keyword in text_lower:
                found.append(keyword)
        return list(set(found))